<?xml version="1.0"?> 
<!--
 <COPYRIGHT>

Copyright (c) 2006, University of Nottingham
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 - Neither the name of the University of Nottingham
   nor the names of its contributors may be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</COPYRIGHT>

Created by: Chris Greenhalgh (University of Nottingham)
 -->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
  <xsl:output method="text"/>
<xsl:variable name="isinterface" select="count(bean/@interface) > 0 and bean/@interface='true'"/>
<xsl:template match="bean">
<xsl:if test="count(@class)!=1">
  <xsl:message terminate="yes">ERROR: Bean must have 'class' attribute specified</xsl:message>
</xsl:if>
<xsl:if test="count(@package)!=1">
  <xsl:message terminate="yes">ERROR: Bean must have 'package' attribute specified</xsl:message>
</xsl:if>
<xsl:if test="count(@interface) > 0 and (@interface!='true' and @interface!='false')">
  <xsl:message terminate="yes">ERROR: If interface attribute is specified it must be 'true' or 'false' (defaults to 'false')</xsl:message>
</xsl:if>
package <xsl:value-of select="@package"/>;
/** <xsl:apply-templates select="description"/><xsl:text>
</xsl:text><xsl:if test="count(@id) != 0"> * Identity element is <xsl:value-of select="@id"/>.
 * 
</xsl:if> * Autogenerated by bean2java.xsl */
public <xsl:choose>
	<xsl:when test="$isinterface">interface </xsl:when>
	<xsl:otherwise>class </xsl:otherwise>
       </xsl:choose><xsl:value-of select="@class"/> 
<xsl:if test="count(@implements)>0 or count(implements)>0">
  <xsl:choose><xsl:when test="$isinterface"> extends </xsl:when><xsl:otherwise> implements </xsl:otherwise></xsl:choose>
  <xsl:for-each select="@implements">
    <xsl:if test="position()>1">, </xsl:if>
    <xsl:value-of select="."/>
  </xsl:for-each>
  <xsl:for-each select="implements">
    <xsl:if test="count(@beanfile)!=1">
      <xsl:message terminate="yes">ERROR: The 'implements' element must have one beanfile attribute specified (interface bean definition filename)</xsl:message>
    </xsl:if>
    <xsl:if test="count(@implements)>0 or position()>1">, </xsl:if>
    <xsl:value-of select="document(@beanfile)/bean/@package"/>.<xsl:value-of select="document(@beanfile)/bean/@class"/>
  </xsl:for-each>
</xsl:if>
{
<xsl:for-each select="constant">
<xsl:if test="position()=1">
  /** constants */
</xsl:if>
<xsl:if test="count(@name)!=1">
  <xsl:message terminate="yes">ERROR: constant must have name attribute specified</xsl:message>
</xsl:if>
<xsl:if test="count(@javatype)!=1">
  <xsl:message terminate="yes">ERROR: constant <xsl:value-of select="@name"/> must have class attribute specified</xsl:message>
</xsl:if>
<xsl:if test="count(@value)!=1">
  <xsl:message terminate="yes">ERROR: constant <xsl:value-of select="@name"/> must have class attribute specified</xsl:message>
</xsl:if>
  /** constant - <xsl:apply-templates select="description"/> */
  public static final <xsl:value-of select="@javatype"/><xsl:text> </xsl:text>
    <xsl:value-of select="@name"/><xsl:text> = </xsl:text>
  <xsl:choose>
    <xsl:when test="@class='java.lang.String'">&quot;<xsl:value-of select="@value"/>&quot;</xsl:when>
    <xsl:otherwise><xsl:value-of select="@value"/></xsl:otherwise>
  </xsl:choose>
  <xsl:text>;</xsl:text>
</xsl:for-each>
<xsl:if test="not($isinterface)">
  /** no-arg cons */
  public <xsl:value-of select="@class"/>()
  {
  }
</xsl:if>
<!-- implement interface method(s) -->
  <xsl:choose>
   <xsl:when test="$isinterface">
     <xsl:for-each select="property">
        <xsl:call-template name="handle-property-in-bean">
          <xsl:with-param name="bean" select="/bean"/>
	  <xsl:with-param name="javatype"><xsl:call-template name="property-type"><xsl:with-param name="bean" select="/bean"/></xsl:call-template></xsl:with-param>
        </xsl:call-template>
     </xsl:for-each>
   </xsl:when>
   <xsl:otherwise>
    <xsl:call-template name="implement-interface">
      <xsl:with-param name="beanfile">.</xsl:with-param>
      <xsl:with-param name="bean" select="/bean"/>
    </xsl:call-template>
   </xsl:otherwise>
  </xsl:choose>
<xsl:apply-templates select="linkedclass"/>  
<xsl:if test="not($isinterface)">
  /** equals */
  public boolean equals(Object o) {
    if (o==null) return false;
    if (!(o instanceof <xsl:value-of select="@class"/>)) return false;
    <xsl:value-of select="@class"/> oo = (<xsl:value-of select="@class"/>)o;
  <xsl:call-template name="implement-interface-equals">
    <xsl:with-param name="beanfile">.</xsl:with-param>
    <xsl:with-param name="bean" select="/bean"/>
  </xsl:call-template>
    return true;
  }
  /** hashcode */
  public int hashCode() {
    int val = 0;
  <xsl:call-template name="implement-interface-hashcode">
    <xsl:with-param name="beanfile">.</xsl:with-param>
    <xsl:with-param name="bean" select="/bean"/>
  </xsl:call-template>
    return val;
  }
  /** tostring */
  public String toString() {
    StringBuilder str = new StringBuilder(&quot;<xsl:value-of select="@class"/>:&quot;);
    <xsl:call-template name="implement-interface-tostring">
	<xsl:with-param name="beanfile">.</xsl:with-param>
	<xsl:with-param name="bean" select="/bean"/>
    </xsl:call-template>
    return str.toString();
  }
</xsl:if>
}
</xsl:template>

<xsl:template name="property-type">
  <xsl:param name="bean"/>
  <xsl:choose>
    <xsl:when test="count(@type)!=0">
    <xsl:variable name="type" select="@type"/>
    <xsl:if test="count($bean/type[@name=$type]/@javatype)!=1">
      <xsl:message terminate="yes">ERROR: type element <xsl:value-of select="@type"/> must have javatype attribute</xsl:message>
    </xsl:if>
    <xsl:value-of select="$bean/type[@name=$type]/@javatype"/>
    </xsl:when>
    <xsl:otherwise><xsl:value-of select="@javatype"/></xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="property-maxlength">
  <xsl:param name="bean"/>
  <xsl:choose>
    <xsl:when test="count(@type)!=0"><xsl:variable name="type" select="@type"/><xsl:value-of select="$bean/type[@name=$type]/@maxlength"/></xsl:when>
    <xsl:otherwise><xsl:value-of select="@maxlength"/></xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="property-elementtype">
  <xsl:param name="bean"/>
  <xsl:choose>
    <xsl:when test="count(@elementtype)!=0"><xsl:variable name="type" select="@elementtype"/><xsl:value-of select="$bean/type[@name=$type]/@javatype"/></xsl:when>
    <xsl:otherwise><xsl:value-of select="@elementjavatype"/></xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="property-elementmaxlength">
  <xsl:param name="bean"/>
  <xsl:choose>
    <xsl:when test="count(@elementtype)!=0"><xsl:variable name="type" select="@elementtype"/><xsl:value-of select="$bean/type[@name=$type]/@maxlength"/></xsl:when>
    <xsl:otherwise><xsl:value-of select="@elementmaxlength"/></xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="property-field-type">
  <xsl:param name="bean"/>
  <xsl:variable name="javatype"><xsl:call-template name="property-type"><xsl:with-param name="bean" select="$bean"/></xsl:call-template></xsl:variable>
  <xsl:variable name="isprimitive" select="$javatype='boolean' or $javatype='byte' or $javatype='char' or $javatype='short' or $javatype='int' or $javatype='long' or $javatype='float' or $javatype='double'"/>
  <xsl:choose>
    <xsl:when test="$javatype='int'">Integer</xsl:when>
    <xsl:when test="$javatype='char'">Character</xsl:when>
    <xsl:when test="$isprimitive"><xsl:value-of select="concat(translate(substring(@javatype,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ'),substring(@javatype,2))"/></xsl:when>
    <xsl:otherwise><xsl:value-of select="$javatype"/></xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="equals">
  <xsl:param name="name"/>
  <xsl:param name="type"/>
  <xsl:param name="indent"/>
  <xsl:param name="depth">0</xsl:param>
  <xsl:variable name="isprimitive" select="$type='boolean' or $type='byte' or $type='char' or $type='short' or $type='int' or $type='long' or $type='float' or $type='double'"/>
  <xsl:variable name="isarray" select="contains($type,'[]')"/>
  <xsl:choose>
    <xsl:when test="$isprimitive"><xsl:value-of select="$indent"/>if (<xsl:value-of select="$name"/>!=oo.<xsl:value-of select="$name"/>) return false;
</xsl:when> 
    <xsl:when test="$isarray">
       <xsl:variable name="eltype" select="substring($type,1,string-length($type)-2)"/>
<xsl:value-of select="$indent"/>if (<xsl:value-of select="$name"/>!=oo.<xsl:value-of select="$name"/>) {
<xsl:value-of select="$indent"/>  if (<xsl:value-of select="$name"/>==null || oo.<xsl:value-of select="$name"/>==null) return false;
<xsl:value-of select="$indent"/>  if (<xsl:value-of select="$name"/>.length!=oo.<xsl:value-of select="$name"/>.length) return false;
<xsl:value-of select="$indent"/>  for (int i<xsl:value-of select="$depth"/>=0; i<xsl:value-of select="$depth"/>&lt;<xsl:value-of select="$name"/>.length; i<xsl:value-of select="$depth"/>++) {
<xsl:call-template name="equals">
  <xsl:with-param name="name" select="concat($name,concat('[i',$depth,']'))"/>
  <xsl:with-param name="type" select="$eltype"/>
  <xsl:with-param name="indent" select="concat($indent,'    ')"/>
  <xsl:with-param name="depth" select="$depth+1"/>
</xsl:call-template>
<xsl:value-of select="$indent"/>  }
<xsl:value-of select="$indent"/>}
</xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$indent"/>if (<xsl:value-of select="$name"/>!=oo.<xsl:value-of select="$name"/> &amp;&amp;
<xsl:value-of select="$indent"/>    (<xsl:value-of select="$name"/>==null || oo.<xsl:value-of select="$name"/>==null ||
<xsl:value-of select="$indent"/>     !<xsl:value-of select="$name"/>.equals(oo.<xsl:value-of select="$name"/>)))
<xsl:value-of select="$indent"/>  return false;
</xsl:otherwise>
  </xsl:choose>  
</xsl:template>


<xsl:template name="hashcode">
  <xsl:param name="name"/>
  <xsl:param name="type"/>
  <xsl:param name="indent"/>
  <xsl:param name="depth">0</xsl:param>
  <xsl:variable name="isnumber" select="$type='byte' or $type='char' or $type='short' or $type='int' or $type='long' or $type='float' or $type='double'"/>
  <xsl:variable name="isarray" select="contains($type,'[]')"/>
  <xsl:choose>
    <xsl:when test="$type='boolean'"><xsl:value-of select="$indent"/>val = val ^ (<xsl:value-of select="$name"/> ? 0 : 1);
</xsl:when> 
    <xsl:when test="$isnumber"><xsl:value-of select="$indent"/>val = val ^ ((int)<xsl:value-of select="$name"/>);
</xsl:when>
    <xsl:when test="$isarray">
       <xsl:variable name="eltype" select="substring($type,1,string-length($type)-2)"/>
<xsl:value-of select="$indent"/>if (<xsl:value-of select="$name"/>!=null) {
<xsl:value-of select="$indent"/>  // only do hash code on first 20 elements (consider a large binary array)
<xsl:value-of select="$indent"/>  for (int i<xsl:value-of select="$depth"/>=0; i<xsl:value-of select="$depth"/>&lt;<xsl:value-of select="$name"/>.length &amp;&amp; i<xsl:value-of select="$depth"/>&lt;20; i<xsl:value-of select="$depth"/>++) {
<xsl:call-template name="hashcode">
  <xsl:with-param name="name" select="concat($name,concat('[i',$depth,']'))"/>
  <xsl:with-param name="type" select="$eltype"/>
  <xsl:with-param name="indent" select="concat($indent,'    ')"/>
  <xsl:with-param name="depth" select="$depth+1"/>
</xsl:call-template>
<xsl:value-of select="$indent"/>  }
<xsl:value-of select="$indent"/>}
</xsl:when>
    <xsl:otherwise><xsl:value-of select="$indent"/>if (<xsl:value-of select="$name"/>!=null) val = val ^ <xsl:value-of select="$name"/>.hashCode();
</xsl:otherwise>
  </xsl:choose>  
</xsl:template>

<!-- can work in any bean def -->
<xsl:template name="handle-property-in-bean">
  <xsl:param name="javatype"/>
  <xsl:param name="bean"/>
  
  <!-- /* handle-property-in-bean: javatype = <xsl:value-of select="$javatype"/> */ -->

  <xsl:variable name="isprimitive" select="$javatype='boolean' or $javatype='byte' or $javatype='char' or $javatype='short' or $javatype='int' or $javatype='long' or $javatype='float' or $javatype='double'"/>
  <xsl:variable name="pname" select="concat(translate(substring(@name,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ'),substring(@name,2))"/>
  <xsl:variable name="ptype"><xsl:call-template name="property-field-type"><xsl:with-param name="bean" select="$bean"/></xsl:call-template></xsl:variable> 
  <xsl:variable name="maxlength"><xsl:call-template name="property-maxlength"><xsl:with-param name="bean" select="$bean"/></xsl:call-template></xsl:variable>
  <xsl:variable name="elementmaxlength"><xsl:call-template name="property-elementmaxlength"><xsl:with-param name="bean" select="$bean"/></xsl:call-template></xsl:variable>
  <xsl:if test="not($isinterface)">
  /** internal value - <xsl:apply-templates select="description"/>
  <xsl:if test="count(@elementtype)!=0 or count(@elementjavatype)!=0">
   * element type is <xsl:call-template name="property-elementtype"><xsl:with-param name="bean" select="$bean"/></xsl:call-template>.
  </xsl:if>
  <xsl:if test="string-length($maxlength)!=0">
   * max length = <xsl:value-of select="$maxlength"/>.
  </xsl:if>
  <xsl:if test="string-length($elementmaxlength)!=0">
   * element max length = <xsl:value-of select="$elementmaxlength"/>.
  </xsl:if>
   */
  protected <xsl:value-of select="$ptype"/><xsl:text> _</xsl:text><xsl:value-of select="@name"/>;
  </xsl:if>
  /** getter - <xsl:apply-templates select="description"/>
  <xsl:if test="count(@elementtype)!=0 or count(@elementjavatype)!=0">
   * element type is <xsl:call-template name="property-elementtype"><xsl:with-param name="bean" select="$bean"/></xsl:call-template>.
  </xsl:if>
<!--  <xsl:variable name="maxlength"><xsl:call-template name="property-maxlength"/></xsl:variable>  -->
  <xsl:if test="string-length($maxlength)!=0">
   * max length = <xsl:value-of select="$maxlength"/>.
  </xsl:if>
<!--  <xsl:variable name="elementmaxlength"><xsl:call-template name="property-elementmaxlength"/></xsl:variable> -->
  <xsl:if test="string-length($elementmaxlength)!=0">
   * element max length = <xsl:value-of select="$elementmaxlength"/>.
  </xsl:if>
   */
  public <xsl:value-of select="$javatype"/><xsl:text> get</xsl:text><xsl:value-of select="$pname"/>()<xsl:choose>
	<xsl:when test="$isinterface">;</xsl:when>
	<xsl:otherwise>
  {
  <xsl:choose>
    <xsl:when test="$isprimitive">
    // default value
    if (_<xsl:value-of select="@name"/>==null)
      <xsl:choose>
        <xsl:when test="$javatype='boolean'">
        return false;
        </xsl:when>
        <xsl:otherwise>
        return 0;
        </xsl:otherwise>
      </xsl:choose> 
    return _<xsl:value-of select="@name"/>.<xsl:value-of select="$javatype"/>Value();
    </xsl:when>
    <xsl:otherwise>
    return _<xsl:value-of select="@name"/>;
    </xsl:otherwise>
  </xsl:choose>
  }
</xsl:otherwise></xsl:choose>
  /** setter - <xsl:apply-templates select="description"/>
  <xsl:if test="count(@elementtype)!=0 or count(@elementjavatype)!=0">
   * element type is <xsl:call-template name="property-elementtype"><xsl:with-param name="bean" select="$bean"/></xsl:call-template>.
  </xsl:if>
  <xsl:if test="string-length($maxlength)!=0">
   * max length = <xsl:value-of select="$maxlength"/>.
  </xsl:if>
<!--  <xsl:variable name="elementmaxlength"><xsl:call-template name="property-elementmaxlength"/></xsl:variable> -->
  <xsl:if test="string-length($elementmaxlength)!=0">
   * element max length = <xsl:value-of select="$elementmaxlength"/>.
  </xsl:if>
   */
  public void set<xsl:value-of select="$pname"/>(<xsl:value-of select="$javatype"/><xsl:text> </xsl:text><xsl:value-of select="@name"/>)<xsl:choose>
	<xsl:when test="$isinterface">;</xsl:when>
	<xsl:otherwise>
  {
  <xsl:choose>
    <xsl:when test="$isprimitive">
    this._<xsl:value-of select="@name"/> = new <xsl:value-of select="$ptype"/>(<xsl:value-of select="@name"/>);
    </xsl:when>
    <xsl:otherwise>
    this._<xsl:value-of select="@name"/> = <xsl:value-of select="@name"/>;
    </xsl:otherwise>
  </xsl:choose>
  }
</xsl:otherwise></xsl:choose>
  /** is set?
   */
  public boolean isSet<xsl:value-of select="$pname"/>()<xsl:choose>
	<xsl:when test="$isinterface">;</xsl:when>
	<xsl:otherwise> {
    return this._<xsl:value-of select="@name"/> != null; 
  }
</xsl:otherwise></xsl:choose>
  /** unset
   */
  public void unset<xsl:value-of select="$pname"/>()<xsl:choose>
	<xsl:when test="$isinterface">;</xsl:when>
	<xsl:otherwise>  {
    this._<xsl:value-of select="@name"/> = null; 
  }
</xsl:otherwise></xsl:choose>
  <xsl:if test="count(@class)!=0">
    <xsl:if test="count(@linkproperty)!=1">
      <xsl:message terminate="yes">ERROR: property <xsl:value-of select="@name"/> with (link) class attribute must also have linkproperty attribute</xsl:message>
    </xsl:if>
    <xsl:variable name="linkedpackage">
      <xsl:choose>
        <xsl:when test="count(@package)!=0"><xsl:value-of select="@package"/></xsl:when>
        <xsl:otherwise><xsl:value-of select="$bean/@package"/></xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <!-- helper method to get template for linked object -->
  /** get match template for identified object 
   */
  public <xsl:value-of select="$linkedpackage"/>.<xsl:value-of select="@class"/> get<xsl:value-of select="$pname"/>Template()<xsl:choose>
	<xsl:when test="$isinterface">;</xsl:when>
	<xsl:otherwise>   {
    if (this._<xsl:value-of select="@name"/>==null) return null;
    <xsl:value-of select="$linkedpackage"/>.<xsl:value-of select="@class"/> t = new <xsl:value-of select="$linkedpackage"/>.<xsl:value-of select="@class"/>();
    <xsl:variable name="plinkproperty" select="concat(translate(substring(@linkproperty,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ'),substring(@linkproperty,2))"/>
    t.set<xsl:value-of select="$plinkproperty"/>( this._<xsl:value-of select="@name"/> );
    return t; 
  }
</xsl:otherwise></xsl:choose>
  </xsl:if>
</xsl:template>

<xsl:template match="description"><xsl:value-of select="."/>
</xsl:template>


<!-- generate linked class template helper, @class, @linkproperty -->
<xsl:template match="linkedclass">
  <xsl:if test="$isinterface">
    <xsl:message terminate="true">ERROR: sorry - linkedclass element not currently supported in interface(s)</xsl:message>
  </xsl:if>
  <xsl:if test="count(@name)!=1">
    <xsl:message terminate="yes">ERROR: linkedclass element must have name attribute</xsl:message>
  </xsl:if>
  <xsl:if test="count(@class)!=1">
    <xsl:message terminate="yes">ERROR: linkedclass <xsl:value-of select="@name"/> must have class attribute</xsl:message>
  </xsl:if>
  <xsl:if test="count(@linkproperty)!=1">
    <xsl:message terminate="yes">ERROR: linkedclass <xsl:value-of select="@name"/> must have linkproperty attribute</xsl:message>
  </xsl:if>
  <xsl:variable name="linkedpackage">
    <xsl:choose>
      <xsl:when test="count(@package)!=0"><xsl:value-of select="@package"/></xsl:when>
      <xsl:otherwise><xsl:value-of select="/bean/@package"/></xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:variable name="pname" select="concat(translate(substring(@name,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ'),substring(@name,2))"/>
  <xsl:variable name="plinkproperty" select="concat(translate(substring(@linkproperty,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ'),substring(@linkproperty,2))"/>
  /** get match template for linked class <xsl:value-of select="$linkedpackage"/>.<xsl:value-of select="@class"/> - <xsl:apply-templates select="description"/>
   */
  public <xsl:value-of select="$linkedpackage"/>.<xsl:value-of select="@class"/> get<xsl:value-of select="$pname"/>Template()<xsl:choose>
	<xsl:when test="$isinterface">;</xsl:when>
	<xsl:otherwise> {
    <xsl:value-of select="$linkedpackage"/>.<xsl:value-of select="@class"/> t = new <xsl:value-of select="$linkedpackage"/>.<xsl:value-of select="@class"/>();
    t.set<xsl:value-of select="$plinkproperty"/>( this._<xsl:value-of select="/bean/@primarykey"/> );
    return t; 
  }
</xsl:otherwise></xsl:choose>
</xsl:template>

<!-- do the actual work of implementing an interface -->
<xsl:template name="implement-interface">
  <xsl:param name="beanfile"/>
  <xsl:param name="bean"/>
  <!-- the trick is to handle each property only once, even when defined from multiple interfaces -->
  <xsl:if test="count($bean)!=1">
    <xsl:message terminate="true">ERROR: Could not find implemented beanfile <xsl:value-of select="$beanfile"/></xsl:message>
  </xsl:if>
  /* implements <xsl:value-of select="$beanfile"/>, i.e. 
    <xsl:value-of select="$bean/@package"/>.<xsl:value-of select="$bean/@class"/> */
  <xsl:if test="count($bean/@id)>0">
    <xsl:if test="count(/bean/@id)=0">
      <xsl:message terminate="true">ERROR: Bean implements an interface with an ID (<xsl:value-of select="$beanfile"/>) but does not have its own ID</xsl:message>
    </xsl:if>
    <xsl:if test="$bean/@id!=/bean/@id">
      <xsl:message terminate="true">ERROR: Bean implements an interface with ID '<xsl:value-of select="$bean/@id"/>' but has its own different ID '<xsl:value-of select="/bean/@id"/>'</xsl:message>
    </xsl:if>
  </xsl:if>
  
  <!-- constants live in the superclass -->
  <xsl:for-each select="$bean/property">
    <!-- is this the 'first' occurance of this property? is it consistent with any others? -->
    <xsl:if test="count(@name)!=1">
      <xsl:message terminate="true">ERROR: un-named property element in implemented beanfile <xsl:value-of select="$beanfile"/></xsl:message>
    </xsl:if>
    <xsl:variable name="property-name" select="@name"/>
    <xsl:variable name="defining-beanfile">
      <xsl:call-template name="find-defining-beanfile">
	<xsl:with-param name="property-name" select="$property-name"/>
        <xsl:with-param name="bean" select="/bean"/>
        <xsl:with-param name="beanfile">.</xsl:with-param>
        <xsl:with-param name="beanfile-list" select="non-existant"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$defining-beanfile=$beanfile">
        <xsl:call-template name="handle-property-in-bean">
          <xsl:with-param name="bean" select="$bean"/>
	  <xsl:with-param name="javatype"><xsl:call-template name="property-type"><xsl:with-param name="bean" select="$bean"/></xsl:call-template></xsl:with-param>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
    /* property <xsl:value-of select="$property-name"/> defined in <xsl:value-of select="$defining-beanfile"/> */
      </xsl:otherwise>
    </xsl:choose>
  </xsl:for-each>
  
  <!-- hope there are no inheritance loops!! -->
  <xsl:for-each select="$bean/implements">
    <xsl:if test="count(./@beanfile)!=1">
      <xsl:message terminate="true">ERROR: Implemented beanfile <xsl:value-of select="$beanfile"/> has an implements element with no 'beanfile' attribute</xsl:message>
    </xsl:if>
    <xsl:call-template name="implement-interface">
      <xsl:with-param name="beanfile" select="@beanfile[1]"/>
      <xsl:with-param name="bean" select="document(@beanfile[1])/bean"/>
    </xsl:call-template>
  </xsl:for-each>
</xsl:template>

<!-- find defining beanfile using depth-first search -->
<xsl:template name="find-defining-beanfile">
  <xsl:param name="property-name"/>
  <xsl:param name="bean"/>
  <xsl:param name="beanfile"/>
  <xsl:param name="beanfile-list"/>
  <!-- <xsl:message>Checking for <xsl:value-of select="$property-name"/> in <xsl:value-of select="$beanfile"/> with list size <xsl:value-of select="count($beanfile-list)"/>...</xsl:message> -->
  <xsl:choose>
    <xsl:when test="$bean/property/@name=$property-name">
      <!-- <xsl:message>Found!</xsl:message> -->
      <xsl:value-of select="$beanfile"/>
    </xsl:when>
    <xsl:when test="count($bean/implements/@beanfile)>0">
      <xsl:call-template name="find-defining-beanfile">
        <xsl:with-param name="property-name" select="$property-name"/>
        <xsl:with-param name="bean" select="document($bean/implements[1]/@beanfile)/bean"/>
        <xsl:with-param name="beanfile" select="$bean/implements[1]/@beanfile[1]"/>
        <xsl:with-param name="beanfile-list" select="$bean/implements[position()>1]/@beanfile[1]|$beanfile-list"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="count($beanfile-list)>0">
      <xsl:call-template name="find-defining-beanfile">
        <xsl:with-param name="property-name" select="$property-name"/>
        <xsl:with-param name="bean" select="document($beanfile-list[1])/bean"/>
        <xsl:with-param name="beanfile" select="$beanfile-list[1]"/>
        <xsl:with-param name="beanfile-list" select="$beanfile-list[position()>1]"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:message terminate="true">Did not find property <xsl:value-of select="$property-name"/></xsl:message>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<!-- part of equals for this interface -->
<xsl:template name="implement-interface-equals">
 <xsl:param name="beanfile"/>
 <xsl:param name="bean"/>
  <!-- the trick is to handle each property only once, even when defined from multiple interfaces -->
  <xsl:for-each select="$bean/property">
    <xsl:variable name="defining-beanfile">
      <xsl:call-template name="find-defining-beanfile">
	<xsl:with-param name="property-name" select="@name"/>
        <xsl:with-param name="bean" select="/bean"/>
        <xsl:with-param name="beanfile">.</xsl:with-param>
        <xsl:with-param name="beanfile-list" select="non-existant"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$defining-beanfile=$beanfile">
	   <xsl:call-template name="equals">
	    <xsl:with-param name="name" select="concat('_',@name)"/>
	    <xsl:with-param name="type"><xsl:call-template name="property-field-type"><xsl:with-param name="bean" select="$bean"/></xsl:call-template></xsl:with-param>
	    <xsl:with-param name="indent"><xsl:text>    </xsl:text></xsl:with-param>
	   </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
    /* property <xsl:value-of select="@name"/> defined in <xsl:value-of select="$defining-beanfile"/> */
      </xsl:otherwise>
    </xsl:choose>
  </xsl:for-each> 
  <!-- hope there are no inheritance loops!! -->
  <xsl:for-each select="$bean/implements">
    <xsl:if test="count(./@beanfile)!=1">
      <xsl:message terminate="true">ERROR: Implemented beanfile <xsl:value-of select="$beanfile"/> has an implements element with no 'beanfile' attribute</xsl:message>
    </xsl:if>
    <xsl:call-template name="implement-interface-equals">
      <xsl:with-param name="beanfile" select="@beanfile[1]"/>
      <xsl:with-param name="bean" select="document(@beanfile[1])/bean"/>
    </xsl:call-template>
  </xsl:for-each>
</xsl:template>

<!-- part of toString for this interface -->
<xsl:template name="implement-interface-tostring">
    <xsl:param name="beanfile"/>
    <xsl:param name="bean"/>
    str.append(&quot;{&quot;);
    <!-- TODO: Should really prioritise ID here -->
    <xsl:for-each select="$bean/property">
	<xsl:if test="position() > 1">str.append(&quot;,&quot;);</xsl:if>
	str.append(&quot;<xsl:value-of select="@name"/>=&quot;);
	if (<xsl:value-of select="concat('_',@name)"/>!=null) {
	    str.append(<xsl:value-of select="concat('_',@name)"/>.toString());
	} else {
	    str.append(&quot;null&quot;);
	}
    </xsl:for-each>
    str.append(&quot;}&quot;);
</xsl:template>
<!-- part of hashcode for this interface -->
<xsl:template name="implement-interface-hashcode">
 <xsl:param name="beanfile"/>
 <xsl:param name="bean"/>
  <!-- the trick is to handle each property only once, even when defined from multiple interfaces -->
  <xsl:for-each select="$bean/property">
    <xsl:variable name="defining-beanfile">
      <xsl:call-template name="find-defining-beanfile">
	<xsl:with-param name="property-name" select="@name"/>
        <xsl:with-param name="bean" select="/bean"/>
        <xsl:with-param name="beanfile">.</xsl:with-param>
        <xsl:with-param name="beanfile-list" select="non-existant"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$defining-beanfile=$beanfile">
  <xsl:call-template name="hashcode">
	    <xsl:with-param name="name" select="concat('_',@name)"/>
	    <xsl:with-param name="type"><xsl:call-template name="property-field-type"><xsl:with-param name="bean" select="$bean"/></xsl:call-template></xsl:with-param>
	    <xsl:with-param name="indent"><xsl:text>    </xsl:text></xsl:with-param>
	  </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
    /* property <xsl:value-of select="@name"/> defined in <xsl:value-of select="$defining-beanfile"/> */
      </xsl:otherwise>
    </xsl:choose>
  </xsl:for-each> 
  <!-- hope there are no inheritance loops!! -->
  <xsl:for-each select="$bean/implements">
    <xsl:if test="count(./@beanfile)!=1">
      <xsl:message terminate="true">ERROR: Implemented beanfile <xsl:value-of select="$beanfile"/> has an implements element with no 'beanfile' attribute</xsl:message>
    </xsl:if>
    <xsl:call-template name="implement-interface-hashcode">
      <xsl:with-param name="beanfile" select="@beanfile[1]"/>
      <xsl:with-param name="bean" select="document(@beanfile[1])/bean"/>
    </xsl:call-template>
  </xsl:for-each>
</xsl:template>

</xsl:stylesheet>
